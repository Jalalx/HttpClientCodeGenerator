using HttpClientGenerator.Internals;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace HttpClientGenerator
{
    [Generator]
    public class HttpClientCodeGenerator : ISourceGenerator
    {
        static readonly SymbolDisplayFormat binaryWriteFormat = new SymbolDisplayFormat(
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable,
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameOnly);

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxContextReceiver is MarkedMethodSyntaxReceiver syntaxReceiver)
            {
                foreach (var group in syntaxReceiver.Methods.GroupBy(f => f.MethodSymbol.ContainingType))
                {
                    var classSource = ProcessClass(group.Key, syntaxReceiver.ImportedNamespaces, group.ToList(), context);
                    var typeName = group.Key.ToDisplayString();
                    context.AddSource(GetAutoGeneratedFileName(typeName), SourceText.From(classSource, Encoding.UTF8));
                }
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForPostInitialization(InitializeDependencies);
            context.RegisterForSyntaxNotifications(() => new MarkedMethodSyntaxReceiver());
        }

        private void InitializeDependencies(GeneratorPostInitializationContext content)
        {
            foreach (var kvp in DependenciesManager.GetDependenciesSourceCode())
            {
                var generatorFileName = kvp.Key;
                if (kvp.Key.EndsWith(".cs"))
                {
                    generatorFileName = kvp.Key.Substring(kvp.Key.Length - 3);
                }

                content.AddSource($"{generatorFileName}.{Guid.NewGuid():N}.generated.cs", SourceText.From(kvp.Value, Encoding.UTF8));
            }
        }

        private static string GetAutoGeneratedFileName(string identifier) => $"HttpClientGenerator.{identifier}.generated.cs";

        private string ProcessClass(INamedTypeSymbol classSymbol, IEnumerable<INamespaceSymbol> namespaceSymbols, List<MarkedMethodSyntaxReceiver.MarkedMethod> methodSymbols, GeneratorExecutionContext _)
        {
            if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
            {
                //TODO: issue a diagnostic that it must be top level type
                return null;
            }

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classSymbol.Name;

            // begin building the generated source
            var source = new SourceBuilder(1);
            foreach (var method in methodSymbols)
            {
                ProcessMethod(source, method.MethodSymbol, method.HttpVerbAttributeSymbol);
            }

            var namespaceBuilder = new StringBuilder();
            foreach (var nsSymbol in namespaceSymbols)
            {
                namespaceBuilder.AppendLine($"using {nsSymbol.ToDisplayString()};");
            }

            var generatedSourceCode = ClientClassTemplate.ClassTemplateWithHttpClientDependency
                .Replace(ClientClassTemplate.ImportNamespaces, namespaceBuilder.ToString())
                .Replace(ClientClassTemplate.Namespace, namespaceName)
                .Replace(ClientClassTemplate.ClassName, className)
                .Replace(ClientClassTemplate.ClassBody, source.ToString());

            return generatedSourceCode;
        }

        private void ProcessMethod(SourceBuilder source, IMethodSymbol method, AttributeData httpVerbAttribute)
        {
            source.Indent();
            source.AppendLine();

            var accessibility = method.DeclaredAccessibility.ToSource();
            var returnTypeName = method.ReturnType.ToDisplayString(binaryWriteFormat);
            var @paramsArr = method.Parameters.Select(parameter => $"{parameter.Type.ToDisplayString()} {parameter.Name}")
                .ToArray();

            source.AppendLine($"{accessibility} partial async {returnTypeName} {method.Name}({string.Join(", ", paramsArr)})");

            GenerateMethodBody(source, method, httpVerbAttribute);
            source.AppendLine();
            source.Unindent();
        }

        private void GenerateMethodBody(SourceBuilder source, IMethodSymbol method, AttributeData httpVerbAttribute)
        {
            source.OpenBraket();

            // Define method variables
            DefineHttpMethodParameter(source, httpVerbAttribute, "@___httpMethod");
            DefinePathAndRouteAndQueryParameter(source, httpVerbAttribute, method, "@___routes", "@___path", "@___queryParams");
            DefineHeaderParameter(source, httpVerbAttribute, "@___headers");

            // Define HTTP invocation
            DefineHelperSendMethodInvocation(source, method);

            source.CloseBraket();
        }

        private static void DefineHelperSendMethodInvocation(SourceBuilder source, IMethodSymbol method)
        {
            var complexParameter = method.GetComplexTypeParameter();
            var methodReturnType = method.ReturnType as INamedTypeSymbol;
            if (methodReturnType.Name == "Task" && methodReturnType.IsGenericType)
            {
                var genericType = methodReturnType.TypeArguments[0].FullName();

                if (complexParameter == null)
                {
                    // HttpClientHelper.SendAsync<TResponse>(...)
                    var sourceCode = $"return await HttpClientGenerator.Shared.HttpClientHelper.SendAsync<{genericType}>(_httpClient, @___httpMethod, @___path, @___headers, @___routes, @___queryParams);";
                    source.AppendLine(sourceCode);
                }
                else
                {
                    // HttpClientHelper.SendDataAsync<TRequest, TResponse>(...)
                    var requestType = complexParameter.Type.FullName();
                    var sourceCode = $"return await HttpClientGenerator.Shared.HttpClientHelper.SendDataAsync<{requestType}, {genericType}>(_httpClient, @___httpMethod, @___path, @___headers, @___routes, @___queryParams, {complexParameter.Name});";
                    source.AppendLine(sourceCode);
                }
            }
            else if (methodReturnType.Name == "Task")
            {
                if (complexParameter == null)
                {
                    // HttpClientHelper.SendAsync(...)
                    var sourceCode = $"await HttpClientGenerator.Shared.HttpClientHelper.SendAsync(_httpClient, @___httpMethod, @___path, @___headers, @___routes, @___queryParams);";
                    source.AppendLine(sourceCode);
                }
                else
                {
                    // HttpClientHelper.SendDataAsync<TRequest>(...)
                    var requestType = complexParameter.Type.FullName();
                    var sourceCode = $"return await HttpClientGenerator.Shared.HttpClientHelper.SendDataAsync<{requestType}>(_httpClient, @___httpMethod, @___path, @___headers, @___routes, @___queryParams, {complexParameter.Name});";
                    source.AppendLine(sourceCode);
                }
            }
            else
            {
                // not supported
                source.AppendLine("/*Method not supported */ return Task.FromResult(0);");
            }
        }

        private void DefineHeaderParameter(SourceBuilder source, AttributeData httpVerbAttribute, string variableName)
        {
            source.AppendLine($"var {variableName} = new Dictionary<string, string>();");
            source.AppendLine("// Header dictionary goes here...");
            source.AppendLine();
        }

        private void DefineHttpMethodParameter(SourceBuilder source, AttributeData httpVerbAttribute, string variableName)
        {
            var httpVerb = "GET";
            switch (httpVerbAttribute.AttributeClass.Name)
            {
                case "HttpGetAttribute":
                    httpVerb = "GET";
                    break;
                case "HttpPatchAttribute":
                    httpVerb = "PATCH";
                    break;
                case "HttpPostAttribute":
                    httpVerb = "POST";
                    break;
                case "HttpPutAttribute":
                    httpVerb = "PUT";
                    break;
                case "HttpOptionAttribute":
                    httpVerb = "OPTION";
                    break;
                case "HttpDeleteAttribute":
                    httpVerb = "DELETE";
                    break;
            }

            source.AppendLine($"const string {variableName} = \"{httpVerb}\";");
            source.AppendLine();
        }

        private void DefinePathAndRouteAndQueryParameter(SourceBuilder source, AttributeData httpVerbAttribute,
                IMethodSymbol method, string routeVariableName, string pathVariableName, string queryVariableName)
        {
            if (method.Parameters.Count(x => x.Type.IsComplexType()) > 1)
            {
                source.AppendError($"Can not have more than one reference type as agrument.");
                return;
            }

            var path = httpVerbAttribute.ConstructorArguments[0].Value?.ToString();
            source.AppendLine($"var {pathVariableName} = \"{path}\";");

            source.AppendLine($"var {routeVariableName} = new Dictionary<string, object>();");

            var matches = Regex.Matches(path, "\\{\\w+\\}");
            var routeMatchedVariables = new HashSet<string>(matches.OfType<Match>().Where(m => m.Success).Select(m => m.Value.Trim('{', '}')));
            foreach (var routeKey in routeMatchedVariables)
            {
                // comparison is case-sensitive
                var methodParameter = method.Parameters.FirstOrDefault(p => p.Name == routeKey);
                if (methodParameter != null)
                {
                    if (methodParameter.Type.IsValueType)
                    {
                        source.AppendLine($"{routeVariableName}[\"{routeKey}\"] = {routeKey};");
                    }
                }
                else
                {
                    source.AppendError($"No parameter for route value {{{routeKey}}} was found!");
                }
            }

            source.AppendLine();
            source.AppendLine($"var {queryVariableName} = new Dictionary<string, object>();");

            var queryStringParams = method.Parameters.Where(p => !p.Type.IsComplexType() && !routeMatchedVariables.Contains(p.Name)).ToArray();
            if (queryStringParams.Length == 0)
            {
                source.AppendLine("// Query String dictionary goes here...");
            }
            else
            {
                foreach (var parameter in queryStringParams)
                {
                    source.AppendLine($"{queryVariableName}[\"{parameter.Name}\"] = {parameter.Name};");
                }
            }

            source.AppendLine();
        }
    }
}
